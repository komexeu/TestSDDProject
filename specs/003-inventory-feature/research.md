# 庫存功能技術研究

## 決策與選型

### 1. 資料庫層級原子操作
- 決策：採用資料庫原子遞減（UPDATE ... WHERE stock >= N）確保高併發下庫存一致性，防止超賣。
- 理由：SQLite/D1 支援單一 SQL 原子操作，效能佳且易於驗證。
- 替代方案：樂觀鎖（版本號）、應用層鎖定、分散式鎖。

### 2. ORM/資料存取
- 決策：沿用 Prisma ORM，維持專案一致性。
- 理由：現有專案已採用 Prisma，開發效率高，型別安全。
- 替代方案：Drizzle ORM、TypeORM。

### 3. API 設計
- 決策：RESTful API，與現有商品管理 API 風格一致。
- 理由：易於前後端協作，便於測試與維護。
- 替代方案：GraphQL。

### 4. 測試策略
- 決策：Jest + 高併發情境模擬（多執行緒/多請求測試）。
- 理由：Jest 已為專案標準，易於撰寫單元與整合測試。
- 替代方案：Mocha、Supertest。

### 5. 庫存異動紀錄
- 決策：每次異動皆寫入 InventoryLog，含操作者、前後數量、原因。
- 理由：方便稽核、追蹤與問題排查。
- 替代方案：僅記錄關鍵異動、或不記錄（不建議）。

## 其他考量
- 管理員驗證、商品資料結構、API 路徑等皆沿用現有專案慣例。
- 若日後需支援分散式部署，建議改用支援 row-level lock 的資料庫（如 PostgreSQL）。
